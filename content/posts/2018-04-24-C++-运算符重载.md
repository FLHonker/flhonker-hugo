---
title: "C++运算符重载"
date: 2018-04-24T12:11:45+08:00
draft: false
author: Frank Liu
categories: "C++"
tags: ["C++"]
---

#  C++运算符重载

#### 5.1 运算符重载的规则

* 运算符重载规则如下： 
①、 C\++中的运算符除了少数几个之外，全部可以重载，而且只能重载C++中已有的运算符。
②、 重载之后运算符的优先级和结合性都不会改变。
③、 运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造。一般来说，重载的功能应当与原有功能相类似，不能改变原运算符的操作对象个数，同时至少要有一个操作对象是自定义类型。
不能重载的运算符只有五个，它们是：成员运算符`.`、指针运算符`*`、作用域运算符`::`、`sizeof`、条件运算符`？:`。 
运算符重载形式有两种，重载为类的`成员函数`和重载为类的`友元函数`。

* 运算符重载的限制条件:
(1) 不可臆造新的运算符。必须把重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中。
(2) 重载运算符坚持4个“不能改变”:
·不能改变运算符操作数的个数；
·不能改变运算符原有的优先级；
·不能改变运算符原有的结合性；
·不能改变运算符原有的语法结构。

#### 5.2 两种重载方式的比较

在多数情况下，将运算符重载为类的成员函数和类的友元函数都是可以的。但成员函数运算符与友元函数运算符也具有各自的一些特点：

(1) 一般情况下，单目运算符最好重载为类的成员函数,双目运算符则最好重载为类的友元函数。

(2) 以下一些双目运算符不能重载为类的友元函数：`=、()、[]、->`。

(3) 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。

(4) 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。

(5) 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。

(6) 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现。

(7) 当需要重载运算符具有`可交换性`时，选择重载为友元函数。

#### 5.3 特殊的运算符重载实例

(1) 重载函数调用运算符“()”
类重载了括号运算符，则该类的对象就可以当成函数一样来使用。另外类里面可以定义数据成员，这样就比普通函数多了一些功能，例如保存一些状态，统计该对象的调用次数等等。这种对象常常用作泛型算法的实参，因为有些泛型算法可以提供自定义的比较函数。例如：
```c++
class ca
{
public:
    int call_times;
    ca(){call_times = 0;}
    
    void operator()(const string &s){
        printf("ca print : %s\n", s.c_str());
        call_times++;
    }
};

int main()
{
    vector<string> vs;

    vs.push_back("abc");
    vs.push_back("def");

    //普通函数也是可以代替仿函数的，只是功能不如仿函数强大
    for_each(vs.begin(), vs.end(), myprint);

    ca a;
    for_each(vs.begin(), vs.end(), a);      //这里要注意，这个是值传递，传的是a的副本
    printf("ca print call times: %d\n", a.call_times);//所以这个地方的a.call_times还是0

    a("haha");
    a("hehe");
    printf("ca print call times: %d\n", a.call_times);  //现在a.call_times的值就是2了
    
    return 0;
}
```
(2) ->运算符重载

箭头操作符与众不同。它可能表现得像二元操作符一样：接受一个对象和一个成员名。对对象解引用以获取成员。不管外表如何，箭头操作符不接受显式形参。
这里没有第二个形参，因为 -> 的右操作数不是表达式，相反，是对应着类成员的一个标识符。没有明显可行的途径将一个标识符作为形参传递给函数，相反，由编译器处理获取成员的工作。

* <b>对重载箭头的返回值的约束</b>
(1) 重载箭头操作符必须返回`指向类类型的指针`，或者返回`定义了自己的箭头操作符的类类型对象`。
(2) 如果返回类型是指针，则内置箭头操作符可用于该指针，编译器对该指针解引用并从结果对象获取指定成员。如果被指向的类型没有定义那个成员，则编译器产生一个错误。
(3) 如果返回类型是类类型的其他对象（或是这种对象的引用），则将递归应用该操作符。编译器检查返回对象所属类型是否具有成员箭头，如果有，就应用那个操作符；否则，编译器产生一个错误。这个过程继续下去，直到返回一个指向带有指定成员的的对象的指针，或者返回某些其他值，在后一种情况下，代码出错。

**Example:**

定义了3个类，C包含B，B包含A。A、B、C都定义了一个action的成员函数。B和C都重载箭头操作符，不同的是B的重载箭头操作符返回的是A类对象的指针，而C的重载箭头操作符返回的是B类对象。

```c++
#include <iostream>
using namespace std;

class A {
public:
	void action(){
		cout << "Action in class A!" << endl;
	}
};

class B {
	A a;
public:
	A* operator->(){
		return &a;
	}
	void action(){
		cout << "Action in class B!" << endl;
	}
};

class C {
	B b;
public:
	B operator->(){
		return b;
	}
	void action(){
		cout << "Action in class C!" << endl;
	}
};

int main(int argc, char *argv[])
{
	C* pc = new C;
	pc->action();
	C c;
	c->action();	
	getchar();
	return 0;
}
```
上面代码输出结果是：
> Action in class C!
> Action in class A!

其中的代码
> C* pc = new C;
> pc->action();

输出的结果是
> Action in class C!

这个结果比较好理解，pc是类对象指针，此时的箭头操作符使用的是内置含义，对pc解引用然后调用对象的成员函数action。
而下面的代码
> C c;
> c->action();

输出的结果是
> Action in class A!

 其实c->action(); 的含义与c.operator->().operator->()->action(); 相同。
c是对象，c后面的箭头操作符使用的是重载箭头操作符，即调用类C的operator->()成员函数。此时返回的是类B的对象，所以调用类B的operator->()成员函数，B的operator->()返回的是指针，所以现在可以使用内置箭头操作符了。对B的operator->()返回的指针进行解引用，然后调用解引用后的对象的成员函数action，此时调用的就是类A的action()。这里存在一个递归调用operator->()的过程，最后再使用一次内置含义的箭头操作符。
